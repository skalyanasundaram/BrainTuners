#include <iostream>
#include <math.h>

using namespace std;

// #define MAX_SIZE 1000000
// #define COUNT(x)  if(!flags[x]) { count--; flags[x] = 1; }

// inline int GCD(unsigned long a, unsigned long b) {

//     unsigned long temp = 0;
//     while(b > 0) {
//         temp = b;
//         b = a % b;
//         a = temp;
//     }
//     return a; 
// }

// int main() {
//     unsigned long n = 0;
//     int flags[MAX_SIZE] = {0};

//     while(cin >> n) {
//         int count = n;
//         int pythogras_triple = 0;
//         for(int i=1;i<=count; i++)
//             flags[i] = 0;

//         for(unsigned long i=1; i<=n; i++)
//             for(unsigned long j=i+1; j<=n; j++)
//                 for(unsigned long k=j+1; k<=n; k++) 
//                     if (pow(i, 2) + pow(j, 2) == pow(k, 2)) {
//                         cout << i << " " << j << " " << k << endl;
//                         COUNT(i);
//                         COUNT(j);
//                         COUNT(k);

//                         if (GCD(i, GCD(j, k)) == 1)
//                             pythogras_triple ++;
//                     }
//         cout << pythogras_triple << " " << count << endl;
//     }
// }


#define MAX_SIZE 1000000
#define COUNT(x)  flags[x] = 1;

inline int GCD(unsigned long a, unsigned long b) {

    unsigned long temp = 0;
    while(b > 0) {
        temp = b;
        b = a % b;
        a = temp;
    }
    return a; 
}

int main() {
    unsigned long N = 0;
    int flags[MAX_SIZE+1] = {0};

    while(cin >> N) {
        unsigned long count = 0;
        unsigned long pythogras_triple = 0;

        unsigned long target = sqrt(N);
        for(unsigned long n=1; n<=target; n++)
            for(unsigned long m=n+1; m<=target; m++) {
                unsigned long x = m*m - n*n;
                unsigned long y = 2 * m * n;
                unsigned long z = m*m + n*n;

                if (z > N)
                    break;
                // COUNT(x);
                // COUNT(y);
                // COUNT(z);
                
                //x,y,z or co-primes iff m,n are co-prime and one of (m,n) should be odd and other should be even
                //wiki: The triple generated by Euclid's formula is primitive if and only if m and n are coprime and m âˆ’ n is odd.
                if (GCD(m,n) == 1 && ((m+n) % 2) != 0)
                    pythogras_triple ++;

                //Euclid's formula does not produce all triples. This can be remedied by inserting an additional parameter k to the formula. 
                //The following will generate all Pythagorean triples (although not uniquely):
                for (unsigned long k=1; k<N; k++) {
                    unsigned long kx = k*x;
                    unsigned long ky = k*y;
                    unsigned long kz = k*z;
                    if (kz > N)
                        break;
                    
                    COUNT(kx);
                    COUNT(ky);
                    COUNT(kz);
                }

            }

        for(unsigned long i=1; i<=N; i++) {
            if(!flags[i])
                count++;
            flags[i] = 0;
        }

        cout << pythogras_triple << " " << count << endl;
    }
    return 0;
}


// 1 2 9 
// 11 14 18
// 19 21 22 23 
